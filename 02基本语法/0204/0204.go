/*
变量的声明周期:
	堆和栈：
	1. 栈：一种拥有特殊规则的线性表数据结构，它只允许往线性表的一端放入数据，从这一端取数据，按照后进先出（LIFO last in first out）的顺序
		往栈中存放元素的过程叫做入栈，入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。
		不允许从栈底获取数据，也不允许对栈成员（除栈顶的成员）进行任何查看和修改操作。
		栈可以用于内存的分配，并且它的分配和回收速度非常快。
	2. 堆：堆在分配内存时，会在内存空间中分配出足够大的空间。
		但是堆有一个缺点是，内存空间比较乱，有无法找到连续的空间的可能。所以，内存分配器就需要对这些空间进行调整优化。
	堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配，但为此付出的代价就是分配速度比较慢，而且会形成内存碎片。

	变量逃逸：
	程序员需要学会自动决定变量的分配方式，以提高运行效率，比如:函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配。

	编译器觉得变量应该分配在堆和栈上的原则是:
		1. 变量是否被取地址
		2. 变量是否发生逃逸

*/
package main

import "fmt"

func void() {

}
func dummy(b int) int {
	var c int
	c = b
	return c
}
func main() {
	fmt.Println("Begin - 逃逸分析示例")
	var a int
	void()
	fmt.Println(a, dummy(0))
	fmt.Println("End - 逃逸分析示例")
	/*
		go run -gcflags "-m -l" C:\Users\Lijie.Shi\Desktop\Go\02基础语法\0204\0204.go
		-gcflags参数是编译参数,其中
			-m 表示进行内存分配分析
			-l 表示避免程序内联，也就是避免进行程序优化
		最终的输出结果如下：
			02基本语法\0204\0204.go:28:13: ... argument does not escape
			02基本语法\0204\0204.go:28:14: "Begin - 逃逸分析示例" escapes to heap
			02基本语法\0204\0204.go:31:13: ... argument does not escape
			02基本语法\0204\0204.go:31:13: a escapes to heap
			02基本语法\0204\0204.go:31:22: dummy(0) escapes to heap
			02基本语法\0204\0204.go:32:13: ... argument does not escape
			02基本语法\0204\0204.go:32:14: "End - 逃逸分析示例" escapes to heap
		结论：
			示例中的变量C是整型，其值通过dummy()的返回值“逃出”了dummy()。c变量值被赋值并作为dummy()函数返回值返回，即使c变量在dummy()函数中分配的内存被释放，
			也不会影响main()中使用dummy()返回的值。c变量使用栈分配不会影响结果.
	*/
}
